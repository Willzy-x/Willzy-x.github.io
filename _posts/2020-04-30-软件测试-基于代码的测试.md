---
layout:     post
title:      软件测试 基于的代码的测试
subtitle:   基于的代码的测试（静态测试和图覆盖）
date:       2020-04-30
author:     HYC
header-img: img/swt/static-test.jpg
catalog: true
tags:
    - 软件测试
    - 图
    - Bugs
---


# 基于代码的软件测试

## 1. 静态测试(Static Testing)

### 1.1 静态测试的定义

- 通过手工检查（评审）或者自动化工具分析（静态分析）的方式对代码或其他项目文档进行检查。
- 直接发现缺陷（引起失效的原因）。
- 发现的典型缺陷：与标准之间的偏差、需求内的错误、设计错误、可维护性不足和错误接口规格说明等等。
- 简而言之就是找到软件中的Fault之所在，也就是常说的Bug。

### 1.2 和动态测试的区别

- 静态测试（static testing）就是不实际运行被测软件，而只是静态地检查程序代码、界面或文档中可能存在的错误的过程。
- 包括对代码测试、界面测试和文档测试三个方面：
  - 对于代码测试，主要测试代码是否符合相应的标准和规范。
  - 对于界面测试，主要测试软件的实际界面与需求中的说明是否相符。
  - 对于文档测试，主要测试用户手册和需求说明是否符合用户的实际需求。

- 动态测试（dynamic testing），指的是实际运行被测程序，输入相应的测试数据，检查实际输出结果和预期结果是否相符的过程，所以判断一个测试属于动态测试还是静态的，唯一的标准就是看是否运行程序。
  - 黑盒测试有可能是动态测试（运行程序，看输入输出），也有可能是静态测（不运行，只看界面）
  - 白盒测试有可能是动态测试（运行程序并分析代码结构），也有可能是静态测试（不运行程序，只静态察看代码）
  - 动态测试有可能是黑盒测试（运行，只看输入输出），也有可能是白盒测试 （运行并分析代码结构）
  - 静态测试有可能是黑盒测试（不运行，只察看界面），也有可能是白盒测试（不运行，只察看代码）


- 静态测试的流程：
  1. 提供被测对象
  2. 准备用户需求
  3. **阅读代码**
  4. **阅读文档**
  5. 报告发现的缺陷
  6. 执行回归测试

- 动态测试的流程：
  1. 提供被测对象
  2. 准备用户需求
  3. **搭建测试环境**
  4. **设计测试用例**
  5. **运行测试用例**
  6. **检查测试结果**
  7. **记录测试过程**
  8. 报告发现的缺陷
  9. 执行回归测试

### 1.3 常用的方法

从上到下由最正式到最随意排列：

- 审查（Inspection）-> 发现缺陷，找到违反既定标准的问题
- 团队评审（Team Review）-> 发现缺陷，达成共识，教育参加者
- 走查（Walk Through）-> 发现缺陷，达成共识，教育参加者
- 结对编程（Pair Programming）-> 发现缺陷并立即修复
- 同行桌查（Peer Desk Check）-> 发现缺陷
- 轮查（Pass Around）-> 发现缺陷
- 特别检查（Ad hoc Review）-> 解决当前问题，单人进行（程序员）

代码评审中发现问题的严重程度

|-----------------+------------|
| 问题             | 严重程度    |
|-----------------|:-----------|
| 命名规则和代码风格 | 低级        |
| 控制结构或逻辑问题 | 中级        |
| 冗余问题         | 高级        |
| 性能问题         | 高级        |
| 安全问题         | 高级        |
| 可测量性问题      | 高级        |
| 功能性问题        | 高级       |
| 错误处理         | 高级        |
| 可重用性问题      | 中级       |
|=================+============|

### 1.4 主要内容

1. 编码的标准和规范
    - 标准：建立起来必须遵守的规则。
    - 规范：建议最佳的做法，推荐更好的方式。
    - 实施标准和规范的原因：
      - 可靠性
      - 可读性和可维护性
      - 可移植性
2. 代码评审
    - 通过阅读代码来检查源代码与编码标准的符合性以及代码质量的活动
    - 评审内容：
      - 编码规范问题
      - 代码结构问题
      - 工具、框架使用不当
      - 实现问题
      - 测试问题

3. 软件复杂度度量

### 1.5 静态分析工具

- 自动检查代码
  - CheckStyle：静态语法检查
  - FindBugs：静态逻辑bug检查
  - SourceMonitor：代码质量检查

- 如何安装：在Eclipse中：Help -> Install Software -> Add -> 输入名字和下载的地址

## 2. 图覆盖

### 2.1 测试中图的定义

- 图$G$表示为$(N,N_0,N_f,E)$
  - $N$代表结点的非空集合, $N_0$代表初始结点的非空集合, $N_f$代表终结点的非空集合, $E$代表边的集合, 其中$E$是$N\times N$的子集。
  - $N$、$N_0$以及$N_f$至少要包含一个结点。
  - 可以存在多余的一个结点。
  - 必须至少存在一个终结点。

- 例子：
    ![example](http://ychu.top/img/swt/post-20200430-eg.jpg)

- $N=\left \{n_0, n_1, n_2, n_3\right \}$
- $N_0=\{n_0\}$
- $E=\{<n_0, n_1>, <n_0, n_2>, <n_1, n_3>, <n_2, n_3>\}$

#### 2.1.1 SESE（单入/单出）

- 所有的测试路径从一个结点开始，结束于一个单一的结点。
- 要求$n_f$从$N$中每一个结点开始是语法可达的，并且$N$除了$n_f$中没有结点是从$n_f$开始语法可达的（除非$n_0$和$n_f$是同一个结点）。

#### 2.1.2 控制流图（Control Flow Graph）

- 描述程序控制结构/逻辑结构。
- 是对程序流程图简化后得到的，突出表示程序控制流的结构。
- 结构：
  - 结点：语句、语句基本块、函数、模块由带标号的圆圈表示
  - 边：控制流转移、跳转、调用由带箭头的弧或线表示
  - 域：由边和结点限定的区间

### 2.2 控制流图的覆盖

- 点覆盖：执行每一行代码
- 边覆盖：执行每一个分支
- 路径覆盖：执行指定路径
- 循环：for循环，while循环
- 数据流覆盖：变量的定义与引用

---

#### 2.2.1 测试路径

- 是从$N_0$中某结点开始到$N_f$中某结点结束的一条路径$p$，该路径的长度可能是0。
  - 测试路径可能代表多个测试执行。
  - 一些测试路径可能不能够被任何测试执行。

- 测试路径$path$与测试用例$t$
  - 路径$path(t)$：测试$ t $的执行路径。
    - 假设一个测试用例$ t $只有一个执行路径
    - 什么时候一个测试用例会有多条执行路径
    - $path(T)$：测试用例集的执行路径集合
    - 可达性：
      - 语法可达：图上存在一个测试路径$p$到达结点$n$、边$e$
      - 语义可达：存在一个测试$t$能够执行到结点$n$、边$e$

- 测试准则（TC Test Criterion）：测试需求的定义规则
- 测试需求（TR Test Requirement）：描述测试路径信息
- 测试用例集 $T$ 满足 (Satisfaction) 测试需求 TR

- 蕴含（Subsume）
  - 定义：对于两个测试准则$C_1$和$C_2$，如果任意满足$C_1$的测试用例集$T$都满足$C_2$，则我们称$C_1$蕴含$C_2$，记作$C_1 \geqq C_2$。
  - 用来刻画测试准则之间的关系。
  - 讨论NCC、ECC、EPCC、CPCC之间的关系。
  - 不能保证bug准则的确定关系。

- 回路覆盖：
  - 图中包含循环，则存在无穷路径，完全路径覆盖不可能也不合理。

- 准则：
  - 点覆盖准则（Node Coverage Criterion）-> 测试需求集TR包含图G中的每一个结点。
  - 边覆盖准则（Edge Coverage Criterion）-> 测试需求集TR包含图G中所有长度不超过1的可达边。
  - 边对覆盖准则（Edge-pair Coverage Criterion）-> 测试需求集TR包含图G中所有长度不超过2的可达边。
  - 完全路径覆盖准则（Complete Path Coverage Criterion）-> 测试需求集TR包含图G中所有可达的路径。
  - N-Path Coverage -> 测试需求集TR包含图G中所有长度不超过N的可达边。VC(n=0),EC(n-1),EPC(n=2),CPC(n=∞)
  - 回路覆盖准则：
    - 简单路径：如果在一条路径$p$中，除了始结点和终结点可以是同样的外，没有任何结点出现多于一次，则称该路径$p$是简单的。
    - 主路径：如果一条简单路径$Cp$的任何真子路径均不是简单的路径，则称它为主路径。
  - 主路径覆盖准则（Primary Path Coverage Criterion）-> $TR$包含图G中所有主路径。
    - 覆盖所有长度为0和1的路径。
    - PPCC Subsume NC / EN。

