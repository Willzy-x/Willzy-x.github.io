---
layout:     post
title:      Java虚拟机学习
subtitle:   垃圾回收机制 (1)
date:       2020-05-04
author:     HYC
header-img: img/post-2020-05-04-jvm-header.jpg
catalog: true
tags:
    - Java
    - JVM
    - 内存管理
---

春招找实习的时候面试Java岗位十有八九会问的JVM中的垃圾回收机制，现在来整理一下。

## 1. 常用的垃圾回收算法

### 1.1 引用计数法(Reference Counting）

引用计数法其实很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就+1，当引用失效时，引用计数器就-1，只要对象A的引用计数器为0，那么A就不可能再被使用。  

虽然这个算法很简单，但是它有两个非常严重的问题：

1. 无法处理循环引用
2. 引用计数器要求在每次引用产生和消除的时候，伴随一个加法操作和一个减法操作，对系统性能有一定影响。

当不可达的对象（指通过根对象进行引用搜索，最终没有被引用到的对象）出现循环引用时，它们的计数器均不为0。

### 1.2 标记清除法（Mark-Sweep）

标记清除法主要分为两个阶段：

1. 标记
2. 清除

在标记阶段，首先通过根节点标记所有从根结点开始的可达对象。因此未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有的未被标记的对象，标记清除法最大的问题就是可能产生空间碎片。也就是说，当使用标记-清除算法对一块连续的内存空间进行垃圾回收的，最后得到的空闲内存空间可能是不连续的。

### 1.3 复制算法（Copying）

复制算法的核心思想是：将原有的内存空间分为两块，每次只使用其中的一块，在进行垃圾回收时，将正在使用内存中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

### 1.4 标记压缩法（Mark-Compact）

标记压缩法是建立在存活对象少、垃圾对象多的情况下的，它是一种老年代回收算法。它在标记清除法的算法上做了一些优化。和标记清除法一样，也是先从根结点开始，对所有的可达对象进行了标记。之后不只是简单地清除未被标记的对象，而是将所有存活的对象都压缩在内存的一端，然后清理边界以外的所有区域。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，性价比很高。

### 1.5 分代算法（Generational Collecting）

分代算法将内存区域根据对象的特点分成几块，根据每块内存区间的特点使用不同的回收算法。

- 新生代，一般来说，Java虚拟机会将所有的新建对象都放入称为新生代的内存区域，新生代的特点是对象朝生夕死，大约90%的对象很快就会被回收，因此比较适合复制算法。
- 老年代，当一个对象经历几次回收后依然存活，对象就会被放入称为老年代的内存空间。

对于新生代和老年代来说，通常新生代的回收频率很高，但是每次回收的耗时很短，而老年代的回收频率比较低，但是会消耗更多的时间。为了支持高频率的新生代回收，虚拟机可能会使用一种叫“卡表”（Card Table）的数据结构。卡表为一个比特位集合，每一个比特位可以用来表示老年代的某一区域是否持有新生代对象的引用。这样在新生代GC时，不用花大量时间扫描所有的老年代对象来确定每一个对象的引用关系，可以先扫描卡表，当卡表的标记为1时，才需要扫描给定区域的老年代对象；而卡表标记为0时，一定不含有新生代对象的引用。

### 1.6 分区算法（Region）

分区算法将整个堆空间划分成连续的不同的区域。每一个小区都独立使用，独立回收。这种算法的好处是可以控制一次回收小区间的数量。

## 2. 对象的可触性和引用

简单地说，可触性一般包含以下3种状态。

- 可触及的：从根结点开始，可以到达这个对象。
- 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()函数中复活。
- 不可触及的：对象的finalize()函数被调用，并没有复活，那么就会进入不可触及的状态，不可触及的对象不可能被复活，因为finalize()函数只会被调用一次。

### 2.1 强引用

强引用一般就是程序中使用的引用类型，强引用的对象是可触及的，不会被回收的。软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下都是可以被回收的。

强引用具备以下几个特点：

- 可以直接访问目标对象。
- 强引用所指向的对象在任何时刻都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用的对象。
- 强引用可能导致内存泄漏。

### 2.2 软引用

软引用是比强引用弱一点的引用类型。如果一个对象只持有软引用，那么当堆空间不足时，就会被回收。软引用使用`java.lang.ref.SoftReference`类实现。

GC时未必会回收软引用对象，但是当内存资源紧张时，软引用对象会被回收，所有软引用对象不会引起内存溢出。

### 2.3 弱引用

在系统GC时，只要发现弱引用，不管系统堆空间使用情况如何，都会对对象进行回收。但是由于垃圾回收器的线程优先级往往比较低，并不一定能很快发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。一旦一个弱引用对象被垃圾回收器回收，便会加入一个注册的引用队列。弱引用使用`java.lang.ref.WeakReference`类实现。

### 2.4 虚引用

虚引用是所有引用类型中的最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的`get()`方法取得强引用时，总会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。

当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。
